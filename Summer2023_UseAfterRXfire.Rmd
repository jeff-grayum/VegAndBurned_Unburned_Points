---
title: "Summer2023_UseAfterRXfire"
output: html_document
date: "2023-09-27"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
#### Libraries ####

library(janitor)
library(tidyverse)
library(ggthemes)
library(lubridate)
library(lme4)
library(readxl)
library(writexl)
library(sf)
library(MuMIn)
library(scales)
library(sjPlot)
library(rsq)
library(betareg)
library(broom)
library(caret)
library(janitor)
library(performance)
library(gam)
library(mgcv)
library(pls)
theme_set(theme_minimal())
```

Importing data. Veg metrics and percent burned already added in 2023 Burned Unburned Locs Veg .rmd
```{r}
#### Importing data ####
s23rx <- read_xlsx("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/SummerLocations/Summer2023/s23rx_no6.xlsx") 
```


Centering and scaling veg covariates
```{r}
s23rx_sc <- s23rx %>% 
  mutate_at(vars(hg:ps), .funs = function(x){as.numeric(scale(x, center = T))}) %>%
  mutate(pib = pib + 0.00001)

s23rx_sc1 <- s23rx_sc %>%
  dplyr::select(pib, dsf, hg:ps)

s23_rx_uniq <- s23rx_sc1[!duplicated(s23rx_sc1), ]
```

Adding in temp data
```{r}
#### importing temp data ####
temp23 <- read_csv("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/Other/IchTempData.csv") %>%
  clean_names() %>%
  mutate(date = as.Date(date, tryFormats = "%m-%d-%Y")) 

temp23 <- temp23[temp23$date %in% seq(as.Date("2023-03-22"), by="day",length.out=143),]

temp23 <- temp23 %>% 
  dplyr::select(date, air_temp_max_c)

start_date_23 <- ymd("2023-03-21")

temp23$dsf <- as.numeric(temp23$date - start_date_23)

s23_rx_uniq_temp <- s23_rx_uniq %>%
  left_join(temp23, by = "dsf")


s23_rx_uniq_temp$year <- 2023

s23_rx_uniq_temp_mod <- s23_rx_uniq_temp %>%
  mutate_at(vars(air_temp_max_c), .funs = function(x){as.numeric(scale(x, center = T))})
```

Plotting use over time
```{r}
#### Plotting use over time ####

# If date is not in Date format
# s23rx$date <- as.Date(s23rx$date)

s23_rx_uniq %>%
  ggplot(aes(dsf, pib)) +
  geom_point(size = 2) +
  labs(x = "Days since fire",
       y = "Proportion of bobwhite in burned areas") +
  theme_bw() +
  scale_x_continuous(breaks = c(0, 30, 60, 90, 120, 150), limits = c(NA, 150)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

s23_pib_dsf <- s23_rx_uniq %>%
 dplyr::select(dsf,pib) %>% 
 view()

s23_pib_dsf$year <- 2023

s22_23_pib_dsf <- rbind(s22_pib_dsf, s23_pib_dsf)

s22_23_pib_dsf %>%
  ggplot(aes(dsf, pib)) +
  geom_point() +
  labs(x = "Days since fire",
       y = "Proportion of bobwhite in burned areas") +
  theme_bw() +
  scale_x_continuous(breaks = c(0, 30, 60, 90, 120, 150), limits = c(NA, 150)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
  facet_wrap(~ year)



```

2023: Univariate candidate models (GAM)
```{r}

#### Candidate models (GAM) 2023 #### 

gmodel1 <- gam(pib ~ dsf,
                     data = s23_rx_uniq,
                     family=betar(link = "logit"),
                     na.action = "na.pass")

summary(gmodel1)

summary(gmodel1)


gmodel2 <- gam(pib ~ pg, 
                  data = s23_rx_uniq,
                  family = betar(link = "logit"),
                  na.action = "na.pass")

summary(gmodel2)

gmodel3 <- gam(pib ~ pf, 
                  data = s23_rx_uniq,
                  family = betar(link = "logit"),
                  na.action = "na.pass")

summary(gmodel3)

gmodel4 <- gam(pib ~ ps,
                  data = s23_rx_uniq,
                  family = betar(link = "logit"),
                  na.action = "na.pass")

summary(gmodel4)

gmodel5 <- gam(pib ~ hg,
                  family = betar(link = "logit"),
                  data = s23_rx_uniq,
                  na.action = "na.pass")

summary(gmodel5)


gmodel6 <- gam(pib ~ hf,
                  family = betar(link = "logit"),
                  data = s23_rx_uniq,
                  na.action = "na.pass")

summary(gmodel6)

gmodel7 <- gam(pib ~ hs,
                   family = betar(link = "logit"),
                  data = s23_rx_uniq,
                  na.action = "na.pass")

summary(gmodel7)

gmodel8 <- gam(pib ~ 1,
                  family = betar(link = "logit"),
                  data = s23_rx_uniq,
                  na.action = "na.pass")

#gmodel9 <- gam(pib ~  dsf + air_temp_max_c,
 #                 family = betar(link = "logit"),
  #                data = s23_rx_uniq_temp_mod,
   #               na.action = "na.pass")



#gmodel10 <- gam(pib ~ air_temp_max_c,
            #      family = betar(link = "logit"),
             #     data = s23_rx_uniq_temp_mod,
              #    na.action = "na.pass")
```

Ranking candidate models (GAM)
```{r}

#### Ranking gam models 2023 ####
# Creating a data frame to store model names and their AIC values
model_names <- c(paste0("gmodel", 1:8))


model_list <- list(gmodel1, gmodel2, gmodel3, gmodel4,
                   gmodel5, gmodel6, gmodel7, gmodel8)


model_aic <- sapply(model_list, AIC)
model_nll <- sapply(model_list, logLik)

# Combine the model names and AIC values into a data frame
model_comparison <- data.frame(Model = model_names, AIC = model_aic, nll = - model_nll)

# Sort the models by AIC value
model_comparison_sorted <- model_comparison %>% 
  arrange(AIC)

# View the sorted data frame
model_comparison_sorted %>% 
  view()

# Calculate the minimum AIC value among all models
min_aic <- min(model_comparison_sorted$AIC)

# Add a column for Delta AIC
model_comparison_sorted <- model_comparison_sorted %>%
  mutate(Delta_AIC = AIC - min_aic)

# View the updated data frame
model_comparison_sorted %>% view()

model_comparison_sorted$rll <- exp(-0.5*model_comparison_sorted$Delta_AIC)
model_comparison_sorted$weight <- model_comparison_sorted$rll/sum(model_comparison_sorted$rll)
model_comparison_sorted$weight <- round(model_comparison_sorted$weight,3)

model_comparison_sorted %>% view

#write_xlsx(model_comparison_sorted, "/Users/jeffgrayum/Downloads/model_comp23_No6.xlsx")
```

```{r}
#### Making predict plot ####

dsf_values <- seq(min(s23_rx_uniq$dsf, na.rm = TRUE), 
                 max(s23_rx_uniq$dsf, na.rm = TRUE), 
                 length.out = 136)

dsf_df <- data.frame(
  hs = rep(mean(s23_rx_uniq$hs), length(dsf_values)),
  hg = rep(mean(s23_rx_uniq$hg), length(dsf_values)),
  hf = rep(mean(s23_rx_uniq$hf), length(dsf_values)),
  pg = rep(mean(s23_rx_uniq$pg), length(dsf_values)),
  pf = rep(mean(s23_rx_uniq$pf), length(dsf_values)),
  ps = rep(mean(s23_rx_uniq$ps), length(dsf_values)),
  dsf = dsf_values
)

dsf_pred23 <- data.frame(predict(gmodel1, newdata = dsf_df, type = "response", se.fit = TRUE))


dsf_pred23$lowCI = (dsf_pred23$fit - (1.96 * dsf_pred23$se.fit))
dsf_pred23$upperCI = (dsf_pred23$fit + (1.96 * dsf_pred23$se.fit))


dsf_pred23 %>%
  ggplot(aes(dsf_values, y = fit)) +
  geom_line() +
  geom_ribbon(aes(ymin = lowCI, ymax = upperCI), fill = "red", alpha = 0.2) +
  labs(x = "Days since fire",
       y = "Proportion of bobwhite predicted in burned areas") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

library(ggplot2)

#### Making predict plot for betareg ####

dsf_values <- seq(min(s23_rx_uniq$dsf, na.rm = TRUE), 
                 max(s23_rx_uniq$dsf, na.rm = TRUE), 
                 length.out = 136)

dsf_df <- data.frame(
  hs = rep(mean(s23_rx_uniq$hs), length(dsf_values)),
  hg = rep(mean(s23_rx_uniq$hg), length(dsf_values)),
  hf = rep(mean(s23_rx_uniq$hf), length(dsf_values)),
  pg = rep(mean(s23_rx_uniq$pg), length(dsf_values)),
  pf = rep(mean(s23_rx_uniq$pf), length(dsf_values)),
  ps = rep(mean(s23_rx_uniq$ps), length(dsf_values)),
  dsf = dsf_values
)

dsf_pred23b <- data.frame(predict(bmodel1, newdata = dsf_df, type = "response"))



dsf_pred23 %>%
  ggplot(aes(dsf_values, y = fit)) +
  geom_line() +
  labs(x = "Days since fire",
       y = "Proportion of bobwhite predicted in burned areas") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))


ggplot() +
  # Raw data points
  geom_point(data = s23_rx_uniq, aes(x = dsf, y = pib), size = 2) +
  # Prediction line and ribbon
  geom_line(data = dsf_pred23, aes(x = dsf_values, y = fit), color = "red", size = 1) +
  #geom_ribbon(data = dsf_pred23, aes(x = dsf_values, ymin = lowCI, ymax = upperCI), fill = "red", alpha = 0.2) +
  labs(x = "Days since fire", y = "Proportion of bobwhite in burned areas") +
  theme_bw() +
  scale_x_continuous(breaks = c(0, 30, 60, 90, 120, 150), limits = c(NA, 150)) +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.title = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.text = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.text.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"),
        plot.title = element_text(family = "Times New Roman"), # For title text if you have one
        plot.subtitle = element_text(family = "Times New Roman")) # For subtitle text if you have one



#ChatGPT approach
# Number of bootstrap replications
n_boot <- 1000

# Store bootstrap predictions
boot_preds <- matrix(NA, nrow = n_boot, ncol = length(dsf_values))

# Perform bootstrapping
set.seed(123) # for reproducibility
for (i in 1:n_boot) {
  # Sample with replacement from the original data
  s23_rx_boot <- s23_rx_uniq[sample(nrow(s23_rx_uniq), replace = TRUE), ]
  # Fit the model to the bootstrap sample
  boot_model <- betareg(pib ~ dsf, data = s23_rx_boot, link = "logit")
  # Predict using the new data
  boot_preds[i, ] <- predict(boot_model, newdata = dsf_df, type = "response")
}


# Calculate the standard errors of the predictions
pred_se <- apply(boot_preds, 2, sd)

# Calculate the 95% confidence intervals using the quantile approach
ci_lower <- apply(boot_preds, 2, quantile, probs = 0.025)
ci_upper <- apply(boot_preds, 2, quantile, probs = 0.975)

# Create a data frame for plotting
dsf_df$PredictedPIB <- predict(bmodel1, newdata = dsf_df, type = "response")
dsf_df$LowerCI <- ci_lower
dsf_df$UpperCI <- ci_upper

# Plot with ggplot2
library(ggplot2)

ggplot(dsf_df, aes(x = dsf)) +
  geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), alpha = 0.2, fill = "red") +
  geom_line(aes(y = PredictedPIB), color = "black") +
  labs(x = "DSF", y = "Predicted PIB", title = "Predicted PIB vs DSF with 95% CI") +
  theme_minimal()

# Assuming you already have `dsf_df` with the columns `PredictedPIB`, `LowerCI`, and `UpperCI` calculated

# Combine the raw data plot with the prediction plot
s23_rx_uniq %>%
  ggplot(aes(x = dsf)) +
  geom_point(aes(y = pib), size = 2) + # Plot the raw data points
  geom_ribbon(data = dsf_df, aes(ymin = LowerCI, ymax = UpperCI), alpha = 0.2, fill = "red") + # Add the CI as a shaded area
  geom_line(data = dsf_df, aes(y = PredictedPIB), color = "black") + # Add the predicted line
  scale_x_continuous(breaks = c(0, 30, 60, 90, 120, 150), limits = c(NA, 150)) +
  labs(
    x = "Days since fire",
    y = "Proportion of bobwhite in burned areas"
  ) +
  theme_bw() +
  theme(
    legend.position = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.text.x = element_text(color = "black", size = 12),
    axis.title.y = element_text(color = "black", size = 12),
    axis.title.x = element_text(color = "black", size = 12),
    legend.title = element_text(color = "black", size = 12),
    legend.text = element_text(color = "black", size = 12),
    axis.text.y = element_text(color = "black", size = 12),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")
  )


```

```{r}
# New data for prediction
DSF_values <- seq(min(s23_rx_uniq$dsf, na.rm = TRUE), 
                  max(s23_rx_uniq$dsf, na.rm = TRUE), 
                  length.out = 100)

pred_data <- data.frame(dsf = DSF_values) # Corrected variable name here

# Predicting values
pred_data$predicted_pib <- predict(bmodel1, newdata = pred_data, type = "response") # Use the corrected data frame name

# Plotting observed data points, saving to p
p <- s23_rx_uniq %>%
  ggplot(aes(dsf, pib)) +
  geom_point(size = 2) + # Plotting the observed data points
  labs(x = "Days since fire",
       y = "Proportion of bobwhite in burned areas") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

# Adding prediction line
p + geom_line(data = pred_data, aes(x = dsf, y = predicted_pib), color = "red", size = 1)

```

Let's try combining 2023/23 data
```{r}
s22_rx_uniq <- s22_rx_uniq %>%
  rename(dsf = DSF)

s22_23_rx_unique <- rbind(
  s22_rx_uniq, s23_rx_uniq
)

s22_rx_uniq_temp_mod <- s22_rx_uniq_temp_mod %>%
  rename(dsf = DSF)

s22_23_temp_mod <- rbind(s22_rx_uniq_temp_mod, s23_rx_uniq_temp_mod)
```

Univariate candidate models (GAM) 2022/23
```{r}
#### Candidate models (GAM) 2022/2023 #### 

gmodel1 <- gam(pib ~ dsf,
                     data = s22_23_temp_mod,
                     family=betar(link = "logit"),
                     na.action = "na.pass")


gmodel2 <- gam(pib ~ pg, 
                  data = s22_23_temp_mod,
                  family = betar(link = "logit"),
                  na.action = "na.pass")

gmodel3 <- gam(pib ~ pf, 
                  data = s22_23_temp_mod,
                  family = betar(link = "logit"),
                  na.action = "na.pass")

gmodel4 <- gam(pib ~ ps,
                  data = s22_23_temp_mod,
                  family = betar(link = "logit"),
                  na.action = "na.pass")

gmodel5 <- gam(pib ~ hg,
                  family = betar(link = "logit"),
                  data = s22_23_temp_mod,
                  na.action = "na.pass")


gmodel6 <- gam(pib ~ hf,
                  family = betar(link = "logit"),
                  data = s22_23_temp_mod,
                  na.action = "na.pass")


gmodel7 <- gam(pib ~ hs,
                   family = betar(link = "logit"),
                  data = s22_23_temp_mod,
                  na.action = "na.pass")

gmodel8 <- gam(pib ~ 1,
                  family = betar(link = "logit"),
                  data = s22_23_temp_mod,
                  na.action = "na.pass")

#gmodel9 <- gam(pib ~  dsf + air_temp_max_c,
                #  family = betar(link = "logit"),
               #   data = s22_23_temp_mod,
               #   na.action = "na.pass")



#gmodel10 <- gam(pib ~ air_temp_max_c,
                 # family = betar(link = "logit"),
                #  data = s22_23_temp_mod,
                #  na.action = "na.pass")

```

```{r}
#Univariate candidate models (GLM2023

#### Candidate models (GLM 2023 #### 

bmodel1 <- betareg(pib ~ dsf,
                     data = s23_rx_uniq,
                     link = "logit",
                     na.action = "na.pass")

summary(bmodel1)


bmodel2 <- betareg(pib ~ pg, 
                  data = s23_rx_uniq,
                  link = "logit",
                  na.action = "na.pass")

bmodel3 <- betareg(pib ~ pf, 
                  data = s23_rx_uniq,
                  link = "logit",
                  na.action = "na.pass")

bmodel4 <- betareg(pib ~ ps,
                  data = s23_rx_uniq,
                  link = "logit",
                  na.action = "na.pass")

bmodel5 <- betareg(pib ~ hg,
                  link = "logit",
                  data = s23_rx_uniq,
                  na.action = "na.pass")


bmodel6 <- betareg(pib ~ hf,
                  link = "logit",
                  data = s23_rx_uniq,
                  na.action = "na.pass")


bmodel7 <- betareg(pib ~ hs,
                  link = "logit",
                  data = s23_rx_uniq,
                  na.action = "na.pass")

bmodel8 <- betareg(pib ~ 1,
                  link = "logit",
                  data = s23_rx_uniq,
                  na.action = "na.pass")

bmodel9 <- betareg(pib ~ dsf + I(dsf^2),
                   data = s23_rx_uniq,
                   link = "logit",
                   na.action = "na.pass")


```

Ranking candidate models (betareg)
```{r}

#### Ranking betareg models 2023 ####
# Creating a data frame to store model names and their AIC values
model_names <- c(paste0("bmodel", 1:9))


model_list <- list(bmodel1, bmodel2, bmodel3, bmodel4,
                   bmodel5, bmodel6, bmodel7, bmodel8, bmodel9)


model_aic <- sapply(model_list, AIC)
model_nll <- sapply(model_list, logLik)

# Combine the model names and AIC values into a data frame
model_comparison <- data.frame(Model = model_names, AIC = model_aic, nll = - model_nll)

# Sort the models by AIC value
model_comparison_sorted <- model_comparison %>% 
  arrange(AIC)

# View the sorted data frame
model_comparison_sorted %>% 
  view()

# Calculate the minimum AIC value among all models
min_aic <- min(model_comparison_sorted$AIC)

# Add a column for Delta AIC
model_comparison_sorted <- model_comparison_sorted %>%
  mutate(Delta_AIC = AIC - min_aic)

# View the updated data frame
model_comparison_sorted %>% view()

model_comparison_sorted$rll <- exp(-0.5*model_comparison_sorted$Delta_AIC)
model_comparison_sorted$weight <- model_comparison_sorted$rll/sum(model_comparison_sorted$rll)
model_comparison_sorted$weight <- round(model_comparison_sorted$weight,3)

model_comparison_sorted %>% view

#write_xlsx(model_comparison_sorted, "/Users/jeffgrayum/Downloads/model_comparison22_23fixed.xlsx")
```


```{r}
#### Predict plots 2022 betatreg ####

# Generating DSF values for prediction
DSF_values <- seq(min(s23_rx_uniq$dsf, na.rm = TRUE), max(s23_rx_uniq$dsf, na.rm = TRUE), length.out = 1000)

newdata <- data.frame(dsf = DSF_values)

# Bootstrapping for confidence intervals
n_boot <- 1000  # Number of bootstrap samples
set.seed(123)   # Set seed for reproducibility
boot_preds <- matrix(NA, nrow = n_boot, ncol = length(DSF_values))

for (i in 1:n_boot) {
  resample_indices <- sample(nrow(s23_rx_uniq), replace = TRUE)
  resample_data <- s23_rx_uniq[resample_indices, ]
  boot_model <- betareg(pib ~  dsf, data = resample_data, link = "logit", na.action = "na.pass")
  boot_preds[i, ] <- predict(boot_model, newdata = newdata, type = "response")
}

# Computing 95% confidence intervals
newdata$ci_lower <- apply(boot_preds, 2, quantile, probs = 0.025)
newdata$ci_upper <- apply(boot_preds, 2, quantile, probs = 0.975)

# Computing predicted PIB values
newdata$predicted_pib <- predict(bmodel1, newdata = newdata, type = "response")

# Plot the raw data, prediction line, and confidence intervals
ggplot(newdata, aes(x = dsf)) +
  geom_point(data = s23_rx_uniq, aes(x = dsf, y = (pib)), size = 2, alpha = 0.7) +  # Raw data points
  geom_line(aes(y = predicted_pib), color = "black", size = 1.2) +  # Prediction line
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, fill = "red") +  # Confidence intervals
  labs(x = "Days since fire", y = "Proportion of bobwhite in burned areas", title = "2023: DSF") +
  theme_bw() +
  scale_x_continuous(breaks = c(0, 30, 60, 90, 120, 150), limits = c(min(DSF_values), max(DSF_values))) +
  theme(
    legend.position = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    axis.text.x = element_text(color = "black", size = 12),
    axis.title.y = element_text(color = "black", size = 12),
    axis.title.x = element_text(color = "black", size = 12),
    plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")
  )

```
Adding AICc
```{r}
#### Adding AICc ####

# Function to calculate AICc
calculate_AICc <- function(model) {
  n <- length(model$model[,1])  
  k <- length(coef(model))
  aic <- AIC(model)
  aicc <- aic + (2 * k * (k + 1)) / (n - k - 1)
  return(aicc)
}

# Applying the AICc calculation for each model
model_aicc <- sapply(model_list, calculate_AICc)

# Adding AICc values to the model comparison data frame
model_comparison <- data.frame(Model = model_names, AIC = model_aic, AICc = model_aicc, nll = - model_nll)

# Sort the models by AIC (not AICc) value as per instruction
model_comparison_sorted <- model_comparison %>%
  arrange(AIC)

# Calculate the minimum AIC value among all models for Delta AIC calculation
min_aic <- min(model_comparison_sorted$AIC)

# Add a column for Delta AIC based on AIC (not AICc)
model_comparison_sorted <- model_comparison_sorted %>%
  mutate(Delta_AIC = AIC - min_aic)

# Relative likelihood and weights calculation remains the same
model_comparison_sorted$rll <- exp(-0.5*model_comparison_sorted$Delta_AIC)
model_comparison_sorted$weight <- model_comparison_sorted$rll / sum(model_comparison_sorted$rll)
model_comparison_sorted$weight <- round(model_comparison_sorted$weight, 3)



# Sort the models by AIC (not AICc) value as per original instructions
model_comparison_sorted <- model_comparison %>%
  arrange(AIC)

# Calculate the minimum AICc value among all models for Delta AICc calculation
min_aicc <- min(model_comparison_sorted$AICc)

# Add a column for Delta AICc based on AICc
model_comparison_sorted <- model_comparison_sorted %>%
  mutate(Delta_AICc = AICc - min_aicc)

# Relative likelihood and weights calculation should be updated to use Delta AICc if desired
model_comparison_sorted$rll <- exp(-0.5*model_comparison_sorted$Delta_AICc)
model_comparison_sorted$weight <- model_comparison_sorted$rll / sum(model_comparison_sorted$rll)
model_comparison_sorted$weight <- round(model_comparison_sorted$weight, 3)

# Print the updated data frame to view changes
print(model_comparison_sorted)

```



Let's try seeing if we can predict prob of burned/unburned by using distance to edge.
```{r}
gmodel_dte <- gam(burned ~ distance_to_edge,
                 family = betar(link = "logit"),
                 data = s23rx_sc,
                 na.action = "na.pass")

dte_values <- seq(min(s23rx_sc$distance_to_edge, na.rm = TRUE), 
                 max(s23rx_sc$distance_to_edge, na.rm = TRUE), 
                 length.out = 1000)

dte_df <- data.frame(
  distance_to_edge = dte_values
)

dte_pred <- data.frame(predict(gmodel_dte, newdata = dte_df, type = "response", se.fit = TRUE))


dte_pred$lowCI = (dte_pred$fit - (1.96 * dte_pred$se.fit))
dte_pred$upperCI = (dte_pred$fit + (1.96 * dte_pred$se.fit))

dte_pred %>%
  ggplot(aes(dte_values, fit)) +
  geom_line() +
  geom_ribbon(aes(ymin = lowCI, ymax = upperCI), fill = "blue", alpha = 0.1) +
  labs(x = "Distance to edge (m) of burn compartment",
       y = "Probability of location falling in burned area",
       title = "Predicted probability of bobwhite being in burned area based on distance to edge") +
  scale_y_continuous(labels = percent)
```


Now, let's see if we can predict probability of use based on distance to edge of burned compartments. We will need to important real/random locations from Ch1 analysis.
```{r}
#### Adding dte to real/random points ####

#Importing map of burned areas, summer 2023.
#Reading burn compartments in again, but as an sf object
burn_compartments_2023 <- st_read("/Volumes/Samsung_T5/BOBWHITE_DATA/Maps/2023_burn_compartments/burn 2023 map/NoAG_NoHW/2023_burn_units_NoAg_NoHW.shp")

# Converting burn_compartments_2022 polygons to line geometries that represent their boundaries. This is necessary to calc min distances later.
burn_compartment_boundaries <- st_boundary(burn_compartments_2023)

# Converting tibble of points to an sf object
s23_locs_sf <- st_as_sf(rsfData_modified_summer2023, coords = c("x_", "y_"), crs = st_crs(burn_compartments_2023))

# Calculating the distance from each point to the nearest line boundary of the burn compartments, storing it in matrix
distance_matrix <- st_distance(s23_locs_sf, burn_compartment_boundaries)

# Applying the function min() to each row (1 does this -- we'd use 2 for columns) in the distance matrix
min_distances <- apply(distance_matrix, 1, min)

# Add the minimum distance to the original tibble as a new column
rsfData_modified_summer2023$distance_to_edge <- min_distances


#Now, we can predict real/random
gmodel_prob_use <- gam(case ~ distance_to_edge,
                 family = betar(link = "logit"),
                 data = rsfData_modified_summer2023,
                 na.action = "na.pass")  
  
  
dte_values <- seq(min(rsfData_modified_summer2023$distance_to_edge, na.rm = TRUE), 
                 max(rsfData_modified_summer2023$distance_to_edge, na.rm = TRUE), 
                 length.out = 1000)

dte_df <- data.frame(
  distance_to_edge = dte_values
)

prob_use_pred <- data.frame(predict(gmodel_prob_use, newdata = dte_df, type = "response", se.fit = TRUE))


prob_use_pred$lowCI = (prob_use_pred$fit - (1.96 * prob_use_pred$se.fit))
prob_use_pred$upperCI = (prob_use_pred$fit + (1.96 * prob_use_pred$se.fit))

prob_use_pred %>%
  ggplot(aes(dte_values, fit)) +
  geom_line() +
  geom_ribbon(aes(ymin = lowCI, ymax = upperCI), fill = "blue", alpha = 0.1) +
  labs(x = "Distance to burn edge (m)",
       y = "Probability of use",
       title = "Predicted probability of use based on distance to edge") +
  scale_y_continuous(labels = percent)

```


```{r}
#### Plotting veg data vs percent in burned ####
s23rx_piv <- s23rx %>%
  select(pg:hs, pib) %>%
  pivot_longer(pg:hs, names_to = "Measurement", values_to = "Value")


s23rx_piv %>% 
  dplyr::filter(Measurement %in% c("pg", "pf", "ps")) %>%
  mutate(Measurement = factor(Measurement, levels = c("pg", "pf", "ps"))) %>%
  ggplot(aes(Value, pib)) +
  geom_point(color = "Midnight Blue") +
  facet_wrap(~ Measurement, scales = "free") +
  labs(x = "% cover",
       y = "% of birds in burned area",
       title = "2023: Percent cover of grasses, forbs, and shrubs vs percent of birds in burned areas") +
  theme_bw()

s23rx_piv %>% 
  dplyr::filter(Measurement %in% c("hg", "hf", "hs")) %>%
  mutate(Measurement = factor(Measurement, levels = c("hg", "hf", "hs"))) %>%
  ggplot(aes(Value, pib)) +
  geom_point(color = "Midnight Blue") +
  facet_wrap(~ Measurement, scales = "free") +
  labs(x = "Height (cm)",
       y = "% of birds in burned area",
       title = "2023: Height of grasses, forbs and shrubs vs percent of birds in burned areas") +
  theme_bw()


s23rx %>%
  ggplot(aes(pg, pib)) +
  geom_point(color = "Midnight Blue") +
  labs(x = "% cover of grasses",
       y = "Perenct of birds in burned area",
       title = "Percent cover grasses vs Percent of birds in burned areas") +
  theme_bw()

s23rx %>%
  ggplot(aes(pf, pib)) +
  geom_point(color = "Midnight Blue") +
  labs(x = "% cover of forbs",
       y = "Perenct of birds in burned area",
       title = "Percent cover forbs vs Percent of birds in burned areas") +
  theme_bw()


s23rx %>%
  ggplot(aes(ps, pib)) +
  geom_point(color = "Midnight Blue") +
  labs(x = "% cover of shrubs",
       y = "Perenct of birds in burned area",
       title = "Percent cover shrubs vs Percent of birds in burned areas")

s23rx %>%
  ggplot(aes(hg, pib)) +
  geom_point(color = "Midnight Blue") +
  labs(x = "Height of grasses (cm)",
       y = "Perenct of birds in burned area",
       title = "Height of grasses vs Percent of birds in burned areas")

s23rx %>%
  ggplot(aes(hf, pib)) +
  geom_point(color = "Midnight Blue") +
  labs(x = "Height of forbs (cm)",
       y = "Perenct of birds in burned area",
       title = "Height of forbs vs Percent of birds in burned areas")

s23rx %>%
  ggplot(aes(hs, pib)) +
  geom_point(color = "Midnight Blue") +
  labs(x = "Height of shrubs (cm)",
       y = "Perenct of birds in burned area",
       title = "Height of shrubs vs Percent of birds in burned areas")
  
```



```{r}
#### Temp/pib ####
degree_label <- paste0("Max ambient temp (", "\u00B0", "C)")

# Color mapping
color_map <- setNames(c("red", "black", "blue"), c(degree_label, "% Bobwhite in burned units", "Bobwhite thermal stress threshold"))

# Assuming s22rx exists and has the relevant columns
# Create dashed line data
dashed_line_data <- data.frame(dsf = c(min(s23rx$dsf), max(s23rx$dsf)),
                               y = c(30.4 * 1.5, 30.4 * 1.5))

s23_rx_uniq_temp %>%
  ggplot(aes(x = dsf)) +
  geom_line(aes(y = air_temp_max_c * 1.5, color = degree_label)) +
  geom_point(aes(y = pib * 100, color = "% Bobwhite in burned units")) +
  geom_line(data = dashed_line_data, aes(y = y, color = "Bobwhite thermal stress threshold"), linetype = "dashed") +
  scale_y_continuous(
    name = "% Bobwhite in burned units",
    sec.axis = sec_axis(~ . / 1.5, name = degree_label)
  ) +
  scale_color_manual(
    values = color_map,
    name = ""
  ) +
  labs(x = "Days since fire",
       y = "% sampled bobwhite in burned units") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12)) +
  scale_x_continuous(breaks = c(0, 30, 60, 90, 120, 150))


s23_rx_uniq_temp_sel <- s23_rx_uniq_temp %>%
  dplyr::select(pib, dsf, air_temp_max_c, year)

s23_rx_uniq_temp_sel <- s23_rx_uniq_temp_sel %>%
  rename(DSF = dsf)

s22_23_rx_uniq_temp_sel <- rbind(s22_rx_uniq_temp_sel, s23_rx_uniq_temp_sel)

dashed_line_data <- data.frame(DSF = c(min(s23rx$dsf), max(s23rx$dsf)),
                               y = c(30.4 * 1.5, 30.4 * 1.5))

s22_23_rx_uniq_temp_sel %>%
  ggplot(aes(x = DSF)) +
  geom_line(aes(y = air_temp_max_c * 1.5, color = degree_label)) +
  geom_point(aes(y = pib * 100, color = "% Bobwhite in burned units")) +
  geom_line(data = dashed_line_data, aes(y = y, color = "Bobwhite thermal stress threshold"), linetype = "dashed") +
  scale_y_continuous(
    name = "% Bobwhite in burned units",
    sec.axis = sec_axis(~ . / 1.5, name = degree_label)
  ) +
  scale_color_manual(
    values = color_map,
    name = ""
  ) +
  labs(x = "Days since fire",
       y = "% sampled bobwhite in burned units") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.title = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.text = element_text(colour = "black", size = 12, family = "Times New Roman"),
        strip.text = element_text(family = "Times New Roman"),
        axis.text.y = element_text(colour = "black", size = 12, family = "Times New Roman")) +
  scale_x_continuous(breaks = c(0, 30, 60, 90, 120, 150)) +
  facet_wrap(~ year)

library(ggplot2)
library(dplyr)

s22_23_rx_uniq_temp_sel %>%
  ggplot(aes(x = DSF)) +
  geom_line(aes(y = air_temp_max_c * 1.5, color = degree_label)) +
  geom_point(aes(y = pib * 100, color = "% Bobwhite in burned units")) +
  geom_line(data = dashed_line_data, aes(y = y, color = "Bobwhite thermal stress threshold"), linetype = "dashed") +
  scale_y_continuous(
    name = "% Bobwhite in burned units",
    sec.axis = sec_axis(~ . / 1.5, name = degree_label)
  ) +
  scale_color_manual(
    values = color_map,
    name = ""
  ) +
  labs(x = "Days since fire",
       y = "% sampled bobwhite in burned units") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.title = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.text = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.text.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        strip.text = element_text(family = "Times New Roman"), # For facet labels
        plot.title = element_text(family = "Times New Roman"), # For plot title if you have one
        plot.subtitle = element_text(family = "Times New Roman")) # For plot subtitle if you have one
  +
  scale_x_continuous(breaks = c(0, 30, 60, 90, 120, 150)) +
  facet_wrap(~ year)





```


```{r}
s23dist <- s23rx %>%
  select(burned, distance_to_edge)

s22_s23_dist <- rbind(s22dist, s23dist)

s22_s23_dist %>%
  rename(Location = burned) %>%
  mutate(Location = factor(Location, labels = c("Unburned", "Burned"))) %>%
  ggplot(aes(x = distance_to_edge, fill = Location)) +
  geom_histogram(alpha = 0.8) +
  labs(x = "Distance to edge of burned unit (m)",
       y = "Count",
       title = "Distance of bobwhite locations to edge of burned units") +
  theme_bw()

+
  scale_x_continuous(breaks = c(0, 100, 200, 300, 400, 500, 600)) +
  theme(panel.grid.minor = element_blank())

s22_s23_dist %>%
  dplyr::filter(burned == 0) %>%
  ggplot(aes(x = distance_to_edge)) +
  geom_histogram()
```

```{r}
global_model <- gam(pib ~ pg + pf + ps + hg + hf + hs + dsf,
 family = betar(link = "logit"),
 data = s22_23_rx_unique,
 na.action  = "na.pass")

summary(global_model)
```


```{r}
s23temp <- s23temp %>%
  rename(dsf = DSF)

s23_rx_uniq_temp <- s23_rx_uniq %>%
  left_join(s23temp, by = join_by(dsf), relationship = "many-to-many")

s23_rx_uniq_temp_mod <- s23_rx_uniq_temp %>%
  mutate_at(vars(air_temp_max_c), .funs = function(x){as.numeric(scale(x, center = T))})


gmodel9 <- gam(pib ~  dsf + air_temp_max_c,
                  family = betar(link = "logit"),
                  data = s23_rx_uniq_temp_mod,
                  na.action = "na.pass")

gmodel10 <- gam(pib ~ air_temp_max_c,
                  family = betar(link = "logit"),
                  data = s23_rx_uniq_temp_mod,
                  na.action = "na.pass")



s22_23_rx_temp_unique

```

```{r}
#### Testing distance to edge and DSF #### 

s23rx_bu <- s23rx %>%
  dplyr::filter(burned == 1)

dist_model23 <- lmer(distance_to_edge ~ dsf + (1 | band_numb),
                   data = s23rx_bu)

summary(dist_model23)

lowerCI <- 0.008575 - (1.96 * 0.040563)
upperCI <- 0.008575 + (1.96 * 0.040563)

#Making predict plots

#Making the predict plot with 95% bootstrapped credible intervals.

dist_pred23 <-lmer(distance_to_edge ~ dsf + (1|band_numb), data = s23rx_bu)

predicted_values23 <- modelr::data_grid(s23rx_bu, distance_to_edge, dsf, band_numb) %>% 
                      modelr::add_predictions(dist_pred23)

pred_dist_23 <- predicted_values23 %>%
group_by(dsf) %>%
  summarize(mean_fit = mean(pred),
            low_ci = quantile(pred, 0.025),
            upper_ci = quantile(pred, 0.975))

pred_dist_23 %>%
  ggplot(aes(dsf, mean_fit)) +
  geom_line() +
 geom_ribbon(aes(ymin = low_ci, ymax = upper_ci), fill = "red", alpha = 0.2) +
   labs(x = "Days since fire",
       y = "Bobwhite distance from edge of burn units") +
  theme_bw() +
 theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"))

library(ggplot2)
library(dplyr)

ggplot() +
  # Raw data points
  geom_point(data = s23rx %>% dplyr::filter(burned == 1), aes(x = dsf, y = distance_to_edge), size = 1) +
  # Prediction line and ribbon
  geom_line(data = pred_dist_23, aes(x = dsf, y = mean_fit)) +
  geom_ribbon(data = pred_dist_23, aes(x = dsf, ymin = low_ci, ymax = upper_ci), fill = "red", alpha = 0.2) +
  labs(x = "Days since fire", y = "Distance from edge (m)") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.title = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.text = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.text.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt"),
        plot.title = element_text(family = "Times New Roman"), # For title text if you have one
        plot.subtitle = element_text(family = "Times New Roman")) # For subtitle text if you have one



```

```{r}
s22_23_dist <- rbind(s22rx %>% select(burned, distance_to_edge), s23rx %>% select(burned, distance_to_edge))

s22_23_dist <- s22_23_dist %>%
  rename(Burned = burned)

s22_23_dist %>%
  dplyr::filter(Burned == 1) %>%
  summarize(median_dte = median(distance_to_edge))

s22_23_dist %>%
  dplyr::filter(Burned == 0) %>%
  summarize(median_dte = median(distance_to_edge))

s22_23_dist %>%
  ggplot(aes(distance_to_edge, fill = factor(Burned))) +
  geom_histogram() +
  scale_fill_manual(values = c("blue", "red")) +
  labs(x = "Distance to edge of burn unit (m)",
       y = "Count") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
  geom_vline(xintercept = c(26.7), linetype = "dashed", color = "red") +
    geom_vline(xintercept = c(26.7), linetype = "dashed", color = "blue")

s22_23_dist %>%
  ggplot(aes(y = distance_to_edge, group = as.factor(Burned), fill = Burned)) +
  geom_boxplot(alpha = 0.5) +
  scale_fill_manual(values = c("blue", "red")) +
  labs(x = "Burn status",
       y = "Distance to edge of burn unit (m)") +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) 

```

```{r}
veglong_22_23_cover %>%
  ggplot(aes(dsf, value/100, color = Year)) +
  geom_line() +
  facet_wrap(~ measurement) +
  theme_bw() +
  theme(legend.position = "right",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.text.x = element_text(colour = "black", size = 12),
        axis.title.y = element_text(colour = "black", size = 12),
        axis.title.x = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
  labs(x = "Days since fire",
       y = "Ground cover") 

veglong_22_23_height %>%
  ggplot(aes(dsf, value, color = Year)) +
  geom_line() +
  facet_wrap(~ measurement) +
  theme_bw() +
  theme(legend.position = "right",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line("black"),
        axis.ticks = element_line("black"),
        axis.title.y = element_text(colour = "black", size = 12),
        legend.title = element_text(colour = "black", size = 12),
        legend.text = element_text(colour = "black", size = 12),
        axis.text.y = element_text(colour = "black", size = 12),
        plot.margin = margin(t = 5, r = 10, b = 5, l = 5, unit = "pt")) +
  labs(x = "Days-since-fire", # Remove x-axis label
       y = "Height (cm)") 

```

How many birds used burned areas in 2023?
```{r}
NOBO_count23 <- s23rx %>%
  dplyr::filter(burned == 1) %>%
  count(band_numb, sort = TRUE)
```

Predicting 2023 veg growth Linear
```{r}
#### Predicting 2023 veg growth. ####
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(lme4)
library(tidyr)
library(scales)  # For better axis formatting

#Veg data
veg_data_2023 <- read_xlsx("/Volumes/Samsung_T5/BOBWHITE_DATA/Clean/VegSurveys/VegSurveys2023.xlsx") %>%
  clean_names() %>%
  mutate(date = as.Date(date)) 

#Convert date column to Date format
veg_data_2023$date <- as.Date(veg_data_2023$date)

# Define burn date and compute days since fire
burn_date <- as.Date("2023-03-21")
veg_data_2023 <- veg_data_2023 %>%
  mutate(days_since_fire = as.numeric(date - burn_date),
         sample_new = (unit - 1) * 10 + sample)  # Create sample ID

# ---------------------------
# Fit Mixed-Effects Models with Linear Term for days_since_fire
# ---------------------------
# Models for vegetation height
grass_height_model_lin23 <- lmer(max_grasses_cm ~ days_since_fire + (1 | sample_new), data = veg_data_2023)
forb_height_model_lin23  <- lmer(max_forbs_cm ~ days_since_fire + (1 | sample_new), data = veg_data_2023)
shrub_height_model_lin23 <- lmer(max_shrubs_cm ~ days_since_fire + (1 | sample_new), data = veg_data_2023)

# Models for percent cover
grass_cover_model_lin23 <- lmer(percent_grasses ~ days_since_fire + (1 | sample_new), data = veg_data_2023)
forb_cover_model_lin23  <- lmer(percent_forbs ~ days_since_fire + (1 | sample_new), data = veg_data_2023)
shrub_cover_model_lin23 <- lmer(percent_shrubs ~ days_since_fire + (1 | sample_new), data = veg_data_2023)

# ---------------------------
# Generate Predictions with Confidence Intervals
# ---------------------------
# Create a sequence of days_since_fire for prediction
pred_days_lin_23 <- data.frame(days_since_fire = seq(0, max(veg_data_2023$days_since_fire, na.rm = TRUE), by = 1))

# Define a function to compute predictions and 95% CI
get_predictions <- function(model, newdata) {
  preds <- predict(model, newdata = newdata, re.form = NA, se.fit = TRUE)
  newdata$fit <- pmax(0, preds$fit)  # Set minimum bound at 0
  newdata$lwr <- pmax(0, preds$fit - 1.96 * preds$se.fit)
  newdata$upr <- pmax(0, preds$fit + 1.96 * preds$se.fit)
  return(newdata)
}

# Generate predictions for each model
pred_height_grass_lin_23 <- get_predictions(grass_height_model_lin23, pred_days_lin_23) %>% mutate(variable = "Grass Height (cm)", type = "Height")
pred_height_forb_lin_23  <- get_predictions(forb_height_model_lin23, pred_days_lin_23) %>% mutate(variable = "Forb Height (cm)", type = "Height")
pred_height_shrub_lin_23 <- get_predictions(shrub_height_model_lin23, pred_days_lin_23) %>% mutate(variable = "Shrub Height (cm)", type = "Height")

pred_cover_grass_lin_23 <- get_predictions(grass_cover_model_lin23, pred_days_lin_23) %>% mutate(variable = "Grass Cover (%)", type = "Cover")
pred_cover_forb_lin_23  <- get_predictions(forb_cover_model_lin23, pred_days_lin_23) %>% mutate(variable = "Forb Cover (%)", type = "Cover")
pred_cover_shrub_lin_23 <- get_predictions(shrub_cover_model_lin23, pred_days_lin_23) %>% mutate(variable = "Shrub Cover (%)", type = "Cover")

# Combine all predictions into one data frame
# Combine the 2023 linear predictions
pred_all_lin_23 <- bind_rows(
  pred_height_grass_lin_23, pred_height_forb_lin_23, pred_height_shrub_lin_23,
  pred_cover_grass_lin_23, pred_cover_forb_lin_23, pred_cover_shrub_lin_23
)


# Ensure the facet order is as desired
pred_all_lin_23$variable <- factor(pred_all_lin_23$variable, 
                            levels = c("Grass Height (cm)", "Forb Height (cm)", "Shrub Height (cm)",
                                       "Grass Cover (%)", "Forb Cover (%)", "Shrub Cover (%)"))

# ---------------------------
# Define Custom Colors
# ---------------------------
custom_colors <- c("Grass Height (cm)" = "green3",
                   "Forb Height (cm)"  = "darkorange2",
                   "Shrub Height (cm)" = "saddlebrown",
                   "Grass Cover (%)"   = "green3",
                   "Forb Cover (%)"    = "darkorange2",
                   "Shrub Cover (%)"   = "saddlebrown")

# ---------------------------
# Plot Predictions with 95% Confidence Intervals
# ---------------------------
ggplot(pred_all_lin_23, aes(x = days_since_fire, y = fit, color = variable, fill = variable)) +
  geom_line(linewidth = 1) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2, color = NA) +
  facet_wrap(~variable, scales = "free_y", nrow = 2) +
  labs(title = "2023: Predicted Vegetation Growth and Cover Over Time (Linear Models)",
       x = "Days Since Fire", y = "Predicted Value") +
  scale_x_continuous(breaks = c(0, 25, 50, 75, 100)) +
  scale_color_manual(values = custom_colors) +
  scale_fill_manual(values = custom_colors) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black", size = 12, family = "Times New Roman"),
        axis.text.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.title = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.text = element_text(colour = "black", size = 12, family = "Times New Roman"),
        plot.title = element_text(size = 14, family = "Times New Roman"),
        plot.subtitle = element_text(size = 12, family = "Times New Roman"),
        plot.caption = element_text(size = 10, family = "Times New Roman"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        axis.ticks = element_line(color = "black"),
        legend.position = "none")

# Load MuMIn for r.squaredGLMM
library(MuMIn)
library(broom.mixed)  # For tidying lmer models

# Function to extract model stats
get_model_stats <- function(model) {
  r2_vals <- r.squaredGLMM(model)
  coefs <- summary(model)$coefficients
  
  # Extract beta and SE for days_since_fire
  beta <- coefs["days_since_fire", "Estimate"]
  se   <- coefs["days_since_fire", "Std. Error"]
  
  data.frame(
    Beta = beta,
    Std_Error = se,
    Marginal_R2 = r2_vals[1],
    Conditional_R2 = r2_vals[2],
    AIC = AIC(model),
    LogLik = logLik(model)[1]
  )
}

# Compile stats for all six models
model_stats_2023_linear <- bind_rows(
  get_model_stats(grass_height_model_lin23) %>% mutate(Model = "Grass Height"),
  get_model_stats(forb_height_model_lin23) %>% mutate(Model = "Forb Height"),
  get_model_stats(shrub_height_model_lin23) %>% mutate(Model = "Shrub Height"),
  get_model_stats(grass_cover_model_lin23) %>% mutate(Model = "Grass Cover"),
  get_model_stats(forb_cover_model_lin23) %>% mutate(Model = "Forb Cover"),
  get_model_stats(shrub_cover_model_lin23) %>% mutate(Model = "Shrub Cover")
)

# View the result
print(model_stats_2023_linear)
```

Now quadratic 2023
```{r}
# Convert date column to Date format
veg_data_2023$date <- as.Date(veg_data_2023$date)

# Define burn date and compute days since fire
burn_date <- as.Date("2023-03-21")
veg_data_2023 <- veg_data_2023 %>%
  mutate(days_since_fire = as.numeric(date - burn_date),
         days_since_fire_sq = days_since_fire^2,
         sample_new = (unit - 1) * 10 + sample)

# ---------------------------
# Fit Mixed-Effects Models with Quadratic Term for days_since_fire
# ---------------------------
# Models for vegetation height
grass_height_model_quad23 <- lmer(max_grasses_cm ~ days_since_fire + days_since_fire_sq + (1 | sample_new), data = veg_data_2023)
forb_height_model_quad23  <- lmer(max_forbs_cm ~ days_since_fire + days_since_fire_sq + (1 | sample_new), data = veg_data_2023)
shrub_height_model_quad23 <- lmer(max_shrubs_cm ~ days_since_fire + days_since_fire_sq + (1 | sample_new), data = veg_data_2023)

# Models for percent cover
grass_cover_model_quad23 <- lmer(percent_grasses ~ days_since_fire + days_since_fire_sq + (1 | sample_new), data = veg_data_2023)
forb_cover_model_quad23  <- lmer(percent_forbs ~ days_since_fire + days_since_fire_sq + (1 | sample_new), data = veg_data_2023)
shrub_cover_model_quad23 <- lmer(percent_shrubs ~ days_since_fire + days_since_fire_sq + (1 | sample_new), data = veg_data_2023)

# ---------------------------
# Generate Predictions with Confidence Intervals
# ---------------------------
# Create a sequence of days_since_fire for prediction
pred_days_quad_23 <- data.frame(days_since_fire = seq(0, max(veg_data_2023$days_since_fire, na.rm = TRUE), by = 1)) %>%
  mutate(days_since_fire_sq = days_since_fire^2)

# Define a function to compute predictions and 95% CI
get_predictions <- function(model, newdata) {
  preds <- predict(model, newdata = newdata, re.form = NA, se.fit = TRUE)
  newdata$fit <- pmax(0, preds$fit)
  newdata$lwr <- pmax(0, preds$fit - 1.96 * preds$se.fit)
  newdata$upr <- pmax(0, preds$fit + 1.96 * preds$se.fit)
  return(newdata)
}

# Generate predictions for each model
pred_height_grass_quad_23 <- get_predictions(grass_height_model_quad23, pred_days_quad_23) %>% mutate(variable = "Grass Height (cm)", type = "Height")
pred_height_forb_quad_23  <- get_predictions(forb_height_model_quad23, pred_days_quad_23) %>% mutate(variable = "Forb Height (cm)", type = "Height")
pred_height_shrub_quad_23 <- get_predictions(shrub_height_model_quad23, pred_days_quad_23) %>% mutate(variable = "Shrub Height (cm)", type = "Height")

pred_cover_grass_quad_23 <- get_predictions(grass_cover_model_quad23, pred_days_quad_23) %>% mutate(variable = "Grass Cover (%)", type = "Cover")
pred_cover_forb_quad_23  <- get_predictions(forb_cover_model_quad23, pred_days_quad_23) %>% mutate(variable = "Forb Cover (%)", type = "Cover")
pred_cover_shrub_quad_23 <- get_predictions(shrub_cover_model_quad23, pred_days_quad_23) %>% mutate(variable = "Shrub Cover (%)", type = "Cover")

# Combine all predictions into one data frame
pred_all_quad_23 <- bind_rows(
  pred_height_grass_quad_23, pred_height_forb_quad_23, pred_height_shrub_quad_23,
  pred_cover_grass_quad_23, pred_cover_forb_quad_23, pred_cover_shrub_quad_23
)

# Ensure the facet order is as desired
pred_all_quad_23$variable <- factor(pred_all_quad_23$variable, 
                            levels = c("Grass Height (cm)", "Forb Height (cm)", "Shrub Height (cm)",
                                       "Grass Cover (%)", "Forb Cover (%)", "Shrub Cover (%)"))

# ---------------------------
# Define Custom Colors
# ---------------------------
custom_colors <- c("Grass Height (cm)" = "green3",
                   "Forb Height (cm)"  = "darkorange2",
                   "Shrub Height (cm)" = "saddlebrown",
                   "Grass Cover (%)"   = "green3",
                   "Forb Cover (%)"    = "darkorange2",
                   "Shrub Cover (%)"   = "saddlebrown")

# ---------------------------
# Plot Predictions with 95% Confidence Intervals
# ---------------------------
ggplot(pred_all_quad_23, aes(x = days_since_fire, y = fit, color = variable, fill = variable)) +
  geom_line(linewidth = 1) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2, color = NA) +
  facet_wrap(~variable, scales = "free_y", nrow = 2) +
  labs(title = "2023: Predicted Vegetation Growth and Cover Over Time (Quadratic Models)",
       x = "Days Since Fire", y = "Predicted Value") +
  scale_x_continuous(breaks = c(0, 25, 50, 75, 100)) +
  scale_color_manual(values = custom_colors) +
  scale_fill_manual(values = custom_colors) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black", size = 12, family = "Times New Roman"),
        axis.text.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.y = element_text(colour = "black", size = 12, family = "Times New Roman"),
        axis.title.x = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.title = element_text(colour = "black", size = 12, family = "Times New Roman"),
        legend.text = element_text(colour = "black", size = 12, family = "Times New Roman"),
        plot.title = element_text(size = 14, family = "Times New Roman"),
        plot.subtitle = element_text(size = 12, family = "Times New Roman"),
        plot.caption = element_text(size = 10, family = "Times New Roman"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        axis.ticks = element_line(color = "black"),
        legend.position = "none")

# ---------------------------
# Extract Model Stats (Quadratic)
# ---------------------------
get_model_stats_quad <- function(model) {
  r2_vals <- r.squaredGLMM(model)
  coefs <- summary(model)$coefficients
  
  beta1 <- coefs["days_since_fire", "Estimate"]
  se1   <- coefs["days_since_fire", "Std. Error"]
  
  beta2 <- coefs["days_since_fire_sq", "Estimate"]
  se2   <- coefs["days_since_fire_sq", "Std. Error"]
  
  data.frame(
    Beta1 = beta1,
    SE1 = se1,
    Beta2 = beta2,
    SE2 = se2,
    Marginal_R2 = r2_vals[1],
    Conditional_R2 = r2_vals[2],
    AIC = AIC(model),
    LogLik = logLik(model)[1]
  )
}

# Compile stats for all six quadratic models
model_stats_2023_quad <- bind_rows(
  get_model_stats_quad(grass_height_model_quad23) %>% mutate(Model = "Grass Height"),
  get_model_stats_quad(forb_height_model_quad23) %>% mutate(Model = "Forb Height"),
  get_model_stats_quad(shrub_height_model_quad23) %>% mutate(Model = "Shrub Height"),
  get_model_stats_quad(grass_cover_model_quad23) %>% mutate(Model = "Grass Cover"),
  get_model_stats_quad(forb_cover_model_quad23) %>% mutate(Model = "Forb Cover"),
  get_model_stats_quad(shrub_cover_model_quad23) %>% mutate(Model = "Shrub Cover")
)

# View results
print(model_stats_2023_quad)

```

